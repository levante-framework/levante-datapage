[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "LEVANTE",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "about.html#palmerpenguins",
    "href": "about.html#palmerpenguins",
    "title": "LEVANTE",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "items.html",
    "href": "items.html",
    "title": "LEVANTE",
    "section": "",
    "text": "function interval(range = [], options = {}) {\n  const [min = 0, max = 1] = range;\n  const {\n    step = .001,\n    label = null,\n    value = [min, max],\n    format = ([start, end]) =&gt; `${start} … ${end}`,\n    color,\n    width,\n    theme,\n    __ns__ = randomScope(),\n  } = options;\n\n  const css = `\n#${__ns__} {\n  //font: 13px/1.2 var(--sans-serif);\n  display: flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: auto;\n  flex-direction: column;\n}\n@media only screen and (min-width: 30em) {\n  #${__ns__} {\n    flex-wrap: nowrap;\n    width: 360px;\n  }\n}\n#${__ns__} .label {\n  //width: 120px;\n  //padding: 5px 0 4px 0;\n  //padding: 5px 0 0 0;\n  //margin-right: 6.5px;\n  flex-shrink: 0;\n}\n#${__ns__} .form {\n  display: flex;\n  width: 100%;\n}\n#${__ns__} .range {\n  flex-shrink: 1;\n  width: 100%;\n}\n#${__ns__} .range-slider {\n  width: 100%;\n}\n  `;\n  \n  const $range = rangeInput({min, max, value: [value[0], value[1]], step, color, width, theme});\n  const $output = html`&lt;output&gt;`;\n  const $view = html`&lt;div id=${__ns__}&gt;\n${label == null ? '' : html`&lt;div class=\"label\"&gt;${label}`}\n&lt;div class=form&gt;\n  &lt;div class=range&gt;\n    ${$range}&lt;div class=range-output&gt;${$output}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n${html`&lt;style&gt;${css}`}\n  `;\n\n  const update = () =&gt; {\n    const content = format([$range.value[0], $range.value[1]]);\n    if(typeof content === 'string') $output.value = content;\n    else {\n      while($output.lastChild) $output.lastChild.remove();\n      $output.appendChild(content);\n    }\n  };\n  $range.oninput = update;\n  update();\n  \n  return Object.defineProperty($view, 'value', {\n    get: () =&gt; $range.value,\n    set: ([a, b]) =&gt; {\n      $range.value = [a, b];\n      update();\n    },\n  });\n}\n\nfunction rangeInput(options = {}) {\n  const {\n    min = 0,\n    max = 100,\n    step = 'any',\n    value: defaultValue = [min, max],\n    color,\n    width,\n    theme = theme_Flat,\n  } = options;\n  \n  const controls = {};\n  const scope = randomScope();\n  const clamp = (a, b, v) =&gt; v &lt; a ? a : v &gt; b ? b : v;\n\n  // Will be used to sanitize values while avoiding floating point issues.\n  const input = html`&lt;input type=range ${{min, max, step}}&gt;`;\n  \n  const dom = html`&lt;div class=${`${scope} range-slider`} style=${{\n    color,\n    width: cssLength(width),\n  }}&gt;\n  ${controls.track = html`&lt;div class=\"range-track\"&gt;\n    ${controls.zone = html`&lt;div class=\"range-track-zone\"&gt;\n      ${controls.range = html`&lt;div class=\"range-select\" tabindex=0&gt;\n        ${controls.min = html`&lt;div class=\"thumb thumb-min\" tabindex=0&gt;`}\n        ${controls.max = html`&lt;div class=\"thumb thumb-max\" tabindex=0&gt;`}\n      `}\n    `}\n  `}\n  ${html`&lt;style&gt;${theme.replace(/:scope\\b/g, '.'+scope)}`}\n&lt;/div&gt;`;\n\n  let value = [], changed = false;\n  Object.defineProperty(dom, 'value', {\n    get: () =&gt; [...value],\n    set: ([a, b]) =&gt; {\n      value = sanitize(a, b);\n      updateRange();\n    },\n  });\n\n  const sanitize = (a, b) =&gt; {\n    a = isNaN(a) ? min : ((input.value = a), input.valueAsNumber);\n    b = isNaN(b) ? max : ((input.value = b), input.valueAsNumber);\n    return [Math.min(a, b), Math.max(a, b)];\n  }\n  \n  const updateRange = () =&gt; {\n    const ratio = v =&gt; (v - min) / (max - min);\n    dom.style.setProperty('--range-min', `${ratio(value[0]) * 100}%`);\n    dom.style.setProperty('--range-max', `${ratio(value[1]) * 100}%`);\n  };\n\n  const dispatch = name =&gt; {\n    dom.dispatchEvent(new Event(name, {bubbles: true}));\n  };\n  const setValue = (vmin, vmax) =&gt; {\n    const [pmin, pmax] = value;\n    value = sanitize(vmin, vmax);\n    updateRange();\n    // Only dispatch if values have changed.\n    if(pmin === value[0] && pmax === value[1]) return;\n    dispatch('input');\n    changed = true;\n  };\n  \n  setValue(...defaultValue);\n  \n  // Mousemove handlers.\n  const handlers = new Map([\n    [controls.min, (dt, ov) =&gt; {\n      const v = clamp(min, ov[1], ov[0] + dt * (max - min));\n      setValue(v, ov[1]);\n    }],\n    [controls.max, (dt, ov) =&gt; {\n      const v = clamp(ov[0], max, ov[1] + dt * (max - min));\n      setValue(ov[0], v);\n    }],\n    [controls.range, (dt, ov) =&gt; {\n      const d = ov[1] - ov[0];\n      const v = clamp(min, max - d, ov[0] + dt * (max - min));\n      setValue(v, v + d);\n    }],\n  ]);\n  \n  // Returns client offset object.\n  const pointer = e =&gt; e.touches ? e.touches[0] : e;\n  // Note: Chrome defaults \"passive\" for touch events to true.\n  const on  = (e, fn) =&gt; e.split(' ').map(e =&gt; document.addEventListener(e, fn, {passive: false}));\n  const off = (e, fn) =&gt; e.split(' ').map(e =&gt; document.removeEventListener(e, fn, {passive: false}));\n  \n  let initialX, initialV, target, dragging = false;\n  function handleDrag(e) {\n    // Gracefully handle exit and reentry of the viewport.\n    if(!e.buttons && !e.touches) {\n      handleDragStop();\n      return;\n    }\n    dragging = true;\n    const w = controls.zone.getBoundingClientRect().width;\n    e.preventDefault();\n    handlers.get(target)((pointer(e).clientX - initialX) / w, initialV);\n  }\n  \n  \n  function handleDragStop(e) {\n    off('mousemove touchmove', handleDrag);\n    off('mouseup touchend', handleDragStop);\n    if(changed) dispatch('change');\n  }\n  \n  invalidation.then(handleDragStop);\n  \n  dom.ontouchstart = dom.onmousedown = e =&gt; {\n    dragging = false;\n    changed = false;\n    if(!handlers.has(e.target)) return;\n    on('mousemove touchmove', handleDrag);\n    on('mouseup touchend', handleDragStop);\n    e.preventDefault();\n    e.stopPropagation();\n    \n    target = e.target;\n    initialX = pointer(e).clientX;\n    initialV = value.slice();\n  };\n  \n  controls.track.onclick = e =&gt; {\n    if(dragging) return;\n    changed = false;\n    const r = controls.zone.getBoundingClientRect();\n    const t = clamp(0, 1, (pointer(e).clientX - r.left) / r.width);\n    const v = min + t * (max - min);\n    const [vmin, vmax] = value, d = vmax - vmin;\n    if(v &lt; vmin) setValue(v, v + d);\n    else if(v &gt; vmax) setValue(v - d, v);\n    if(changed) dispatch('change');\n  };\n  \n  return dom;\n}\n\nfunction randomScope(prefix = 'scope-') {\n  return prefix + (performance.now() + Math.random()).toString(32).replace('.', '-');\n}\n\ncssLength = v =&gt; v == null ? null : typeof v === 'number' ? `${v}px` : `${v}`\n\nhtml = htl.html\n\ntheme_Flat = `\n/* Options */\n:scope {\n  color: #3b99fc;\n  width: 240px;\n}\n\n:scope {\n  position: relative;\n  display: inline-block;\n  --thumb-size: 15px;\n  --thumb-radius: calc(var(--thumb-size) / 2);\n  //padding: var(--thumb-radius) 0;\n  margin: 2px;\n  vertical-align: middle;\n}\n:scope .range-track {\n  box-sizing: border-box;\n  position: relative;\n  height: 7px;\n  background-color: hsl(0, 0%, 80%);\n  overflow: visible;\n  border-radius: 4px;\n  padding: 0 var(--thumb-radius);\n}\n:scope .range-track-zone {\n  box-sizing: border-box;\n  position: relative;\n}\n:scope .range-select {\n  box-sizing: border-box;\n  position: relative;\n  left: var(--range-min);\n  width: calc(var(--range-max) - var(--range-min));\n  cursor: ew-resize;\n  background: currentColor;\n  height: 7px;\n  border: inherit;\n}\n/* Expands the hotspot area. */\n:scope .range-select:before {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: var(--thumb-size);\n  left: 0;\n  top: calc(2px - var(--thumb-radius));\n}\n:scope .range-select:focus,\n:scope .thumb:focus {\n  outline: none;\n}\n:scope .thumb {\n  box-sizing: border-box;\n  position: absolute;\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n\n  background: #fcfcfc;\n  top: -4px;\n  border-radius: 100%;\n  border: 1px solid hsl(0,0%,55%);\n  cursor: default;\n  margin: 0;\n}\n:scope .thumb:active {\n  box-shadow: inset 0 var(--thumb-size) #0002;\n}\n:scope .thumb-min {\n  left: calc(-1px - var(--thumb-radius));\n}\n:scope .thumb-max {\n  right: calc(-1px - var(--thumb-radius));\n}\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntol = ({\n    QualBright: ['#4477AA', '#EE6677', '#228833', '#CCBB44', '#66CCEE','#AA3377'],\n    QualHighContrast: ['#004488', '#DDAA33', '#BB5566'],\n    QualVibrant: ['#EE7733', '#0077BB', '#33BBEE', '#EE3377', '#CC3311', '#009988'],\n    QualMuted: ['#CC6677', '#332288', '#DDCC77', '#117733', '#88CCEE','#882255', '#44AA99', '#999933', '#AA4499'],\n    QualLight: ['#77AADD', '#EE8866', '#EEDD88', '#FFAABB', '#99DDFF', '#44BB99', '#BBCC33', '#AAAA00'],\n    Sunset: ['#364B9A', '#4A7BB7', '#6EA6CD', '#98CAE1', '#C2E4EF', '#EAECCC', '#FEDA8B', '#FDB366', '#F67E4B', '#DD3D2D', '#A50026'],\n    BuRd: ['#2166AC', '#4393C3', '#92C5DE', '#D1E5F0', '#F7F7F7', '#FDDBC7', '#F4A582', '#D6604D', '#B2182B'],\n    PRGn: ['#762A83', '#9970AB', '#C2A5CF', '#E7D4E8', '#F7F7F7', '#D9F0D3', '#ACD39E', '#5AAE61', '#1B7837'],\n    YlOrBr: ['#FFFFE5', '#FFF7BC', '#FEE391', '#FEC44F', '#FB9A29',\n                '#EC7014', '#CC4C02', '#993404', '#662506'],\n    Iridescent: ['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF',\n                '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1',\n                '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD',\n                '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388',\n                '#805770', '#684957', '#46353A'],\n    RainbowPuRd: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222'],\n    RainbowPuBr: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222', '#B8221E', '#95211B', '#721E17',\n                '#521A13'],\n    RainbowWhRd: ['#E8ECFB', '#DDD8EF', '#D1C1E1', '#C3A8D1', '#B58FC2',\n                '#A778B4', '#9B62A7', '#8C4E99', '#6F4C9B', '#6059A9',\n                '#5568B8', '#4E79C5', '#4D8AC6', '#4E96BC', '#549EB3',\n                '#59A5A9', '#60AB9E', '#69B190', '#77B77D', '#8CBC68',\n                '#A6BE54', '#BEBC48', '#D1B541', '#DDAA3C', '#E49C39',\n                '#E78C35', '#E67932', '#E4632D', '#DF4828', '#DA2222'],\n    RainbowDiscrete: ['#E8ECFB', '#D9CCE3', '#D1BBD7', '#CAACCB', '#BA8DB4',\n                '#AE76A3', '#AA6F9E', '#994F88', '#882E72', '#1965B0',\n                '#437DBF', '#5289C7', '#6195CF', '#7BAFDE', '#4EB265',\n                '#90C987', '#CAE0AB', '#F7F056', '#F7CB45', '#F6C141',\n                '#F4A736', '#F1932D', '#EE8026', '#E8601C', '#E65518',\n                '#DC050C', '#A5170E', '#72190E', '#42150A']\n})\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 80px;\n  }\n\n  form.${ns} {\n    flex-wrap: wrap;\n  }\n  \n  .plot-inputs form.${ns} {\n    flex-direction: column;\n  }\n  \n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    margin-bottom: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #fbe4b4;\n  }\n  \n  .${ns} input[type=\"checkbox\"] {\n    accent-color: black;\n    margin-bottom: 0;\n  }\n\n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    //width: auto;\n  }\n  \n  .${ns} .hist {\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    row-gap: 0em;\n  }\n\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot = import(\"https://esm.sh/@observablehq/plot@0.6.17\")\nitems = transpose(params)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntasks = d3.group(items, d =&gt; d.task_label)\nviewof task_items = Inputs.select(tasks, { label: \"Task\", value: tasks.get(\"Math\") })\ngroups = new Set(task_items.map(d =&gt; d.item_group))\n\nitem_vars = [\"item_group\", \"item_entry\", \"difficulty\", \"n_responses\"]\nitem_channels = Object.fromEntries(item_vars.map(k =&gt; [k, k]))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  style: { fontFamily: \"var(--sans-serif)\", fontSize: 12 },\n  width: 700,\n height: Math.max(150, 50 * groups.size),\n marginLeft: 110,\n   grid: true,\n  facet: { label: null, grid: true },\n  //fy: { padding: 20 },\n  x: { line: true },\n  //y: { insetBottom: 100 },\n  color: { legend: false, scheme: \"viridis\" },\n  r: {range: [1, 4] },\n  marks: [\n    //Plot.frame(),\n    Plot.dot(task_items, Plot.dodgeY(\"middle\", {\n      x: \"difficulty\",\n      fy: \"item_group\",\n      fill: \"item_group\",\n      r: \"n_responses\",\n      sort: {fy: \"x\", color: \"x\", reduce: \"median\"}\n    })),\n    Plot.tip(task_items, Plot.pointer({\n      x: \"difficulty\",\n      fy: \"item_group\",\n      fill: \"item_group\",\n      channels: item_channels,\n      format: { fy: null }\n    }))\n  ]\n})"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LEVANTE scores",
    "section": "",
    "text": "function interval(range = [], options = {}) {\n  const [min = 0, max = 1] = range;\n  const {\n    step = .001,\n    label = null,\n    value = [min, max],\n    format = ([start, end]) =&gt; `${start} … ${end}`,\n    color,\n    width,\n    theme,\n    __ns__ = randomScope(),\n  } = options;\n\n  const css = `\n#${__ns__} {\n  //font: 13px/1.2 var(--sans-serif);\n  display: flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: auto;\n  flex-direction: column;\n}\n@media only screen and (min-width: 30em) {\n  #${__ns__} {\n    flex-wrap: nowrap;\n    width: 360px;\n  }\n}\n#${__ns__} .label {\n  //width: 120px;\n  //padding: 5px 0 4px 0;\n  //padding: 5px 0 0 0;\n  //margin-right: 6.5px;\n  flex-shrink: 0;\n}\n#${__ns__} .form {\n  display: flex;\n  width: 100%;\n}\n#${__ns__} .range {\n  flex-shrink: 1;\n  width: 100%;\n}\n#${__ns__} .range-slider {\n  width: 100%;\n}\n  `;\n  \n  const $range = rangeInput({min, max, value: [value[0], value[1]], step, color, width, theme});\n  const $output = html`&lt;output&gt;`;\n  const $view = html`&lt;div id=${__ns__}&gt;\n${label == null ? '' : html`&lt;div class=\"label\"&gt;${label}`}\n&lt;div class=form&gt;\n  &lt;div class=range&gt;\n    ${$range}&lt;div class=range-output&gt;${$output}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n${html`&lt;style&gt;${css}`}\n  `;\n\n  const update = () =&gt; {\n    const content = format([$range.value[0], $range.value[1]]);\n    if(typeof content === 'string') $output.value = content;\n    else {\n      while($output.lastChild) $output.lastChild.remove();\n      $output.appendChild(content);\n    }\n  };\n  $range.oninput = update;\n  update();\n  \n  return Object.defineProperty($view, 'value', {\n    get: () =&gt; $range.value,\n    set: ([a, b]) =&gt; {\n      $range.value = [a, b];\n      update();\n    },\n  });\n}\n\nfunction rangeInput(options = {}) {\n  const {\n    min = 0,\n    max = 100,\n    step = 'any',\n    value: defaultValue = [min, max],\n    color,\n    width,\n    theme = theme_Flat,\n  } = options;\n  \n  const controls = {};\n  const scope = randomScope();\n  const clamp = (a, b, v) =&gt; v &lt; a ? a : v &gt; b ? b : v;\n\n  // Will be used to sanitize values while avoiding floating point issues.\n  const input = html`&lt;input type=range ${{min, max, step}}&gt;`;\n  \n  const dom = html`&lt;div class=${`${scope} range-slider`} style=${{\n    color,\n    width: cssLength(width),\n  }}&gt;\n  ${controls.track = html`&lt;div class=\"range-track\"&gt;\n    ${controls.zone = html`&lt;div class=\"range-track-zone\"&gt;\n      ${controls.range = html`&lt;div class=\"range-select\" tabindex=0&gt;\n        ${controls.min = html`&lt;div class=\"thumb thumb-min\" tabindex=0&gt;`}\n        ${controls.max = html`&lt;div class=\"thumb thumb-max\" tabindex=0&gt;`}\n      `}\n    `}\n  `}\n  ${html`&lt;style&gt;${theme.replace(/:scope\\b/g, '.'+scope)}`}\n&lt;/div&gt;`;\n\n  let value = [], changed = false;\n  Object.defineProperty(dom, 'value', {\n    get: () =&gt; [...value],\n    set: ([a, b]) =&gt; {\n      value = sanitize(a, b);\n      updateRange();\n    },\n  });\n\n  const sanitize = (a, b) =&gt; {\n    a = isNaN(a) ? min : ((input.value = a), input.valueAsNumber);\n    b = isNaN(b) ? max : ((input.value = b), input.valueAsNumber);\n    return [Math.min(a, b), Math.max(a, b)];\n  }\n  \n  const updateRange = () =&gt; {\n    const ratio = v =&gt; (v - min) / (max - min);\n    dom.style.setProperty('--range-min', `${ratio(value[0]) * 100}%`);\n    dom.style.setProperty('--range-max', `${ratio(value[1]) * 100}%`);\n  };\n\n  const dispatch = name =&gt; {\n    dom.dispatchEvent(new Event(name, {bubbles: true}));\n  };\n  const setValue = (vmin, vmax) =&gt; {\n    const [pmin, pmax] = value;\n    value = sanitize(vmin, vmax);\n    updateRange();\n    // Only dispatch if values have changed.\n    if(pmin === value[0] && pmax === value[1]) return;\n    dispatch('input');\n    changed = true;\n  };\n  \n  setValue(...defaultValue);\n  \n  // Mousemove handlers.\n  const handlers = new Map([\n    [controls.min, (dt, ov) =&gt; {\n      const v = clamp(min, ov[1], ov[0] + dt * (max - min));\n      setValue(v, ov[1]);\n    }],\n    [controls.max, (dt, ov) =&gt; {\n      const v = clamp(ov[0], max, ov[1] + dt * (max - min));\n      setValue(ov[0], v);\n    }],\n    [controls.range, (dt, ov) =&gt; {\n      const d = ov[1] - ov[0];\n      const v = clamp(min, max - d, ov[0] + dt * (max - min));\n      setValue(v, v + d);\n    }],\n  ]);\n  \n  // Returns client offset object.\n  const pointer = e =&gt; e.touches ? e.touches[0] : e;\n  // Note: Chrome defaults \"passive\" for touch events to true.\n  const on  = (e, fn) =&gt; e.split(' ').map(e =&gt; document.addEventListener(e, fn, {passive: false}));\n  const off = (e, fn) =&gt; e.split(' ').map(e =&gt; document.removeEventListener(e, fn, {passive: false}));\n  \n  let initialX, initialV, target, dragging = false;\n  function handleDrag(e) {\n    // Gracefully handle exit and reentry of the viewport.\n    if(!e.buttons && !e.touches) {\n      handleDragStop();\n      return;\n    }\n    dragging = true;\n    const w = controls.zone.getBoundingClientRect().width;\n    e.preventDefault();\n    handlers.get(target)((pointer(e).clientX - initialX) / w, initialV);\n  }\n  \n  \n  function handleDragStop(e) {\n    off('mousemove touchmove', handleDrag);\n    off('mouseup touchend', handleDragStop);\n    if(changed) dispatch('change');\n  }\n  \n  invalidation.then(handleDragStop);\n  \n  dom.ontouchstart = dom.onmousedown = e =&gt; {\n    dragging = false;\n    changed = false;\n    if(!handlers.has(e.target)) return;\n    on('mousemove touchmove', handleDrag);\n    on('mouseup touchend', handleDragStop);\n    e.preventDefault();\n    e.stopPropagation();\n    \n    target = e.target;\n    initialX = pointer(e).clientX;\n    initialV = value.slice();\n  };\n  \n  controls.track.onclick = e =&gt; {\n    if(dragging) return;\n    changed = false;\n    const r = controls.zone.getBoundingClientRect();\n    const t = clamp(0, 1, (pointer(e).clientX - r.left) / r.width);\n    const v = min + t * (max - min);\n    const [vmin, vmax] = value, d = vmax - vmin;\n    if(v &lt; vmin) setValue(v, v + d);\n    else if(v &gt; vmax) setValue(v - d, v);\n    if(changed) dispatch('change');\n  };\n  \n  return dom;\n}\n\nfunction randomScope(prefix = 'scope-') {\n  return prefix + (performance.now() + Math.random()).toString(32).replace('.', '-');\n}\n\ncssLength = v =&gt; v == null ? null : typeof v === 'number' ? `${v}px` : `${v}`\n\nhtml = htl.html\n\ntheme_Flat = `\n/* Options */\n:scope {\n  color: #3b99fc;\n  width: 240px;\n}\n\n:scope {\n  position: relative;\n  display: inline-block;\n  --thumb-size: 15px;\n  --thumb-radius: calc(var(--thumb-size) / 2);\n  //padding: var(--thumb-radius) 0;\n  margin: 2px;\n  vertical-align: middle;\n}\n:scope .range-track {\n  box-sizing: border-box;\n  position: relative;\n  height: 7px;\n  background-color: hsl(0, 0%, 80%);\n  overflow: visible;\n  border-radius: 4px;\n  padding: 0 var(--thumb-radius);\n}\n:scope .range-track-zone {\n  box-sizing: border-box;\n  position: relative;\n}\n:scope .range-select {\n  box-sizing: border-box;\n  position: relative;\n  left: var(--range-min);\n  width: calc(var(--range-max) - var(--range-min));\n  cursor: ew-resize;\n  background: currentColor;\n  height: 7px;\n  border: inherit;\n}\n/* Expands the hotspot area. */\n:scope .range-select:before {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: var(--thumb-size);\n  left: 0;\n  top: calc(2px - var(--thumb-radius));\n}\n:scope .range-select:focus,\n:scope .thumb:focus {\n  outline: none;\n}\n:scope .thumb {\n  box-sizing: border-box;\n  position: absolute;\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n\n  background: #fcfcfc;\n  top: -4px;\n  border-radius: 100%;\n  border: 1px solid hsl(0,0%,55%);\n  cursor: default;\n  margin: 0;\n}\n:scope .thumb:active {\n  box-shadow: inset 0 var(--thumb-size) #0002;\n}\n:scope .thumb-min {\n  left: calc(-1px - var(--thumb-radius));\n}\n:scope .thumb-max {\n  right: calc(-1px - var(--thumb-radius));\n}\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntol = ({\n    QualBright: ['#4477AA', '#EE6677', '#228833', '#CCBB44', '#66CCEE','#AA3377'],\n    QualHighContrast: ['#004488', '#DDAA33', '#BB5566'],\n    QualVibrant: ['#EE7733', '#0077BB', '#33BBEE', '#EE3377', '#CC3311', '#009988'],\n    QualMuted: ['#CC6677', '#332288', '#DDCC77', '#117733', '#88CCEE','#882255', '#44AA99', '#999933', '#AA4499'],\n    QualLight: ['#77AADD', '#EE8866', '#EEDD88', '#FFAABB', '#99DDFF', '#44BB99', '#BBCC33', '#AAAA00'],\n    Sunset: ['#364B9A', '#4A7BB7', '#6EA6CD', '#98CAE1', '#C2E4EF', '#EAECCC', '#FEDA8B', '#FDB366', '#F67E4B', '#DD3D2D', '#A50026'],\n    BuRd: ['#2166AC', '#4393C3', '#92C5DE', '#D1E5F0', '#F7F7F7', '#FDDBC7', '#F4A582', '#D6604D', '#B2182B'],\n    PRGn: ['#762A83', '#9970AB', '#C2A5CF', '#E7D4E8', '#F7F7F7', '#D9F0D3', '#ACD39E', '#5AAE61', '#1B7837'],\n    YlOrBr: ['#FFFFE5', '#FFF7BC', '#FEE391', '#FEC44F', '#FB9A29',\n                '#EC7014', '#CC4C02', '#993404', '#662506'],\n    Iridescent: ['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF',\n                '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1',\n                '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD',\n                '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388',\n                '#805770', '#684957', '#46353A'],\n    RainbowPuRd: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222'],\n    RainbowPuBr: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222', '#B8221E', '#95211B', '#721E17',\n                '#521A13'],\n    RainbowWhRd: ['#E8ECFB', '#DDD8EF', '#D1C1E1', '#C3A8D1', '#B58FC2',\n                '#A778B4', '#9B62A7', '#8C4E99', '#6F4C9B', '#6059A9',\n                '#5568B8', '#4E79C5', '#4D8AC6', '#4E96BC', '#549EB3',\n                '#59A5A9', '#60AB9E', '#69B190', '#77B77D', '#8CBC68',\n                '#A6BE54', '#BEBC48', '#D1B541', '#DDAA3C', '#E49C39',\n                '#E78C35', '#E67932', '#E4632D', '#DF4828', '#DA2222'],\n    RainbowDiscrete: ['#E8ECFB', '#D9CCE3', '#D1BBD7', '#CAACCB', '#BA8DB4',\n                '#AE76A3', '#AA6F9E', '#994F88', '#882E72', '#1965B0',\n                '#437DBF', '#5289C7', '#6195CF', '#7BAFDE', '#4EB265',\n                '#90C987', '#CAE0AB', '#F7F056', '#F7CB45', '#F6C141',\n                '#F4A736', '#F1932D', '#EE8026', '#E8601C', '#E65518',\n                '#DC050C', '#A5170E', '#72190E', '#42150A']\n})\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 80px;\n  }\n\n  form.${ns} {\n    flex-wrap: wrap;\n  }\n  \n  .plot-inputs form.${ns} {\n    flex-direction: column;\n  }\n  \n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    margin-bottom: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #fbe4b4;\n  }\n  \n  .${ns} input[type=\"checkbox\"] {\n    accent-color: black;\n    margin-bottom: 0;\n  }\n\n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    //width: auto;\n  }\n  \n  .${ns} .hist {\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    row-gap: 0em;\n  }\n\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot = import(\"https://esm.sh/@observablehq/plot@0.6.17\")\nscores = transpose(data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvi = ({\n  \"age\":           { label: \"Age (years)\",      filter: true,  tip: true,  range: [5, 12] },\n  \"age_gap\":       { label: \"Age gap (months)\", filter: true,  tip: false, range: [0, 24] },\n  \"score\":         { label: \"Score\",            filter: false, tip: true,  range: null    },\n  \"score_se\":      { label: \"Score SE\",         filter: false, tip: true,  range: null    },\n  \"num_attempted\": { label: \"num_attempted\",    filter: false, tip: true,  range: null    }\n})\n\n//d3.max(line_summary.map(d =&gt; d.age_gap))\n\n// info for categorical variables\n// color = include in color dropdown?, tip = include in tooltip?\n// note: filter property not actually used programmatically\nti = ({\n  \"site\":          { label: \"Site\",          filter: true,  color: true,  tip: true  },\n  \"dataset\":       { label: \"Dataset\",       filter: true,  color: true,  tip: true  },\n  \"task_label\":    { label: \"Task\",          filter: true,  color: false, tip: false },\n  \"language\":      { label: \"Language\",      filter: true,  color: true,  tip: false },\n  \"adaptive\":      { label: \"Adaptive\",      filter: true,  color: true,  tip: false },\n  \"score_type\":    { label: \"Score type\",    filter: true,  color: true,  tip: false },\n  \"scoring_model\": { label: \"Scoring model\", filter: true,  color: true,  tip: false },\n  \"run_id\":        { label: \"run_id\",        filter: false, color: false, tip: true  },\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninterval_format = ([start, end]) =&gt; `[${Plot.formatNumber(\"en-US\")(start)}; ${Plot.formatNumber(\"en-US\")(end)}]`\n\n// integer-rounded min and max of an array\n// range = (x) =&gt; [Math.floor(d3.min(x)), Math.ceil(d3.max(x))]\n\n// interval input for a given numeric variable\nvar_interval = (v) =&gt; {\n  return interval(vi[v].range, {\n    step: 1, label: vi[v].label, format: interval_format, width: \"95%\", color: \"#f7ca69\"\n  })\n}\n\n// checkbox input for a given categorical variable\ncat_checkbox = (t) =&gt; Inputs.checkbox(tags[t], {value: tags[t]})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScoresItems\n\n\nviewof age_range = var_interval(\"age\")\nviewof age_gap_range = var_interval(\"age_gap\")\nviewof site_vals = cat_checkbox(\"site\")\nviewof dataset_vals = cat_checkbox(\"dataset\")\nviewof task_label_vals = cat_checkbox(\"task_label\")\nviewof language_vals = cat_checkbox(\"language\")\nviewof adaptive_vals = cat_checkbox(\"adaptive\")\nviewof score_type_vals = cat_checkbox(\"score_type\")\nviewof scoring_model_vals = cat_checkbox(\"scoring_model\")\nrange_filter = (v, v_range) =&gt; {\n  return (d) =&gt; d[v] &gt;= v_range[0] & d[v] &lt;= v_range[1]\n}\n\n// generate overlap filter function for a given categorical variable and input values\noverlap_filter = (t, t_vals) =&gt; {\n  return (d) =&gt; t_vals.some(v =&gt; d[t].includes(v))\n}\n\n// generate overlap filter function as above but that defaults to including everything if input values empty\noverlap_null_filter = (t, t_vals) =&gt; {\n  return (d) =&gt; t_vals.length ? t_vals.some(v =&gt; d[t].includes(v)) : true\n}\n\n// specify range-based inputs (as variable, values)\nrange_inputs = ([\n  { v: \"age\", vals: age_range },\n])\n\n// specify overlap-based inputs (as variable, values)\noverlap_inputs = ([\n  { v: \"site\",          vals: site_vals          },\n  { v: \"dataset\",       vals: dataset_vals       },\n  { v: \"task_label\",    vals: task_label_vals    },\n  { v: \"language\",      vals: language_vals      },\n  { v: \"adaptive\",      vals: adaptive_vals      },\n  { v: \"score_type\",    vals: score_type_vals    },\n  { v: \"scoring_model\", vals: scoring_model_vals },\n])\n\n// generate filter function for each input and combine them\nrange_filters = range_inputs.map(({ v, vals }) =&gt; range_filter(v, vals))\noverlap_filters = overlap_inputs.map(({ v, vals }) =&gt; overlap_filter(v, vals))\nall_filters = [...range_filters, ...overlap_filters]\n\n// apply filters to score data\nsf = all_filters.reduce((sc, fun) =&gt; sc.filter(fun), scores)\n\n// apply age gap filter\nag = ls.filter(d =&gt; d.age_gap === null || (d.age_gap &gt;= age_gap_range[0] & d.age_gap &lt;= age_gap_range[1]))\nag_runs = ag.map(d =&gt; d.runs).flat()\nscoresf = sf.filter(d =&gt; ag_runs.includes(d.run_id))\n// plot type selector\nviewof plot_type = Inputs.radio(\n  new Map([[\"Cross-sectional\", \"dot\"], [\"Longitudinal\", \"line\"]]),\n  {value: \"dot\", label: \"Data view\"}\n)\ncat_array = Object.keys(ti).filter((t) =&gt; ti[t].color).map((t) =&gt; [ti[t].label, t])\ncat_vars = new Map([[\"None\", null], ...cat_array])\nviewof color_var = Inputs.select(cat_vars, {value: \"site\", label: \"Color\"})\nx_var = \"age\"        // x\ny_var = \"score\"      // y\nr_var = \"score_se\"   // dot radius\nz_var = \"user_id\"    // line group\nf_var = \"task_label\" // facets\n\n//\n// plot colors\n// set up to keep color mapping consistent regardless of filters but include\n// only present values in legend\n//\nscheme = tol.QualMuted // color scheme\ndefault_color = scheme[0] // default color when there's no color variable\nunk_color = \"lightgrey\" // color for missing values\nplt_color = color_var || default_color // plot color variable\n// color variable values -- null or all possible values for variable except NA\ncolor_vals = color_var === null ? [default_color] : tags[color_var].filter((v) =&gt; v !== \"NA\")\n\n// domain: values + NA\ncolor_domain = [...color_vals, \"NA\"]\n// range: corresponding values from scheme + missing color\ncolor_range = [...scheme.slice(0, color_vals.length), unk_color]\n// map from domain to range\ncolor_map = color_domain.map((v, i) =&gt; [v, color_range[i]])\n// drop elements from map if values not in data\ncolors = Object.fromEntries(color_map.filter(([k, v]) =&gt; scoresf.map((d) =&gt; d[color_var]).includes(k)))\n\n// create facet specification to emulate facet wrap\n// given data, column name to facet by, and number of columns\nfacet_wrap = (df, col, ncol) =&gt; {\n  const keys = Array.from(d3.union(df.map((d) =&gt; d[col])));\n  const index = new Map(keys.map((key, i) =&gt; [key, i]));\n  const fx = (key) =&gt; index.get(key) % ncol;\n  const fy = (key) =&gt; Math.floor(index.get(key) / ncol);\n  return ({\n    fx: (d) =&gt; fx(d[col]),\n    fy: (d) =&gt; fy(d[col]),\n    text: Plot.text(keys, {fx, fy, dy: -12, frameAnchor: \"top\", fontWeight: \"bold\"})\n    //text: Plot.text(keys, {fx, fy, frameAnchor: \"top\", fontWeight: \"bold\"})\n  })\n}\nall_vars = [...Object.entries(ti), ...Object.entries(vi)] // all variables\ntip_vars = all_vars.filter(([k, v]) =&gt; v.tip) // variables with \"tip\" property\ndot_channels = Object.fromEntries(tip_vars.map(([k, v]) =&gt; [k, k]))\n\n// marks for dots\ndot_marks = Plot.marks(\n  // facet labels\n  dot_facet.text,\n  // points\n  Plot.dot(scoresf, {\n    x: x_var,\n    y: y_var,\n    r: r_var,\n    stroke: plt_color,\n    strokeOpacity: 0.5,\n    fx: dot_facet.fx,\n    fy: dot_facet.fy\n  }),\n  // regression lines\n  Plot.linearRegressionY(scoresf, {\n    x: x_var,\n    y: y_var,\n    stroke: \"black\",\n    fx: dot_facet.fx,\n    fy: dot_facet.fy\n  }),\n  // tooltips\n  Plot.tip(scoresf, Plot.pointer({\n    x: x_var,\n    y: y_var,\n    stroke: plt_color,\n    fx: dot_facet.fx,\n    fy: dot_facet.fy,\n    channels: dot_channels,\n    format: { fx: null, fy: null }\n  }))\n)\nls = Array.from(\n  d3.group(sf, d =&gt; d[f_var], d =&gt; d[z_var]),\n  ([f_val, z_map]) =&gt; Array.from(\n    z_map,\n    ([z_val, points]) =&gt; ({\n      [f_var]: f_val,\n      [z_var]: z_val,\n      [color_var]: points[0][color_var],\n      [x_var]: d3.mean(points, d =&gt; d[x_var]),\n      [y_var]: d3.mean(points, d =&gt; d[y_var]),\n      n_scores: points.length,\n      age_gap: 12*(d3.max(points, d =&gt; d[x_var]) - d3.min(points, d =&gt; d[x_var])),\n      runs: points.map(d =&gt; d.run_id)\n//      [`${x_var}_mean`]: d3.mean(points, d =&gt; d[x_var]),\n//      [`${y_var}_mean`]: d3.mean(points, d =&gt; d[y_var]),\n//      [`${x_var}_range`]: d3.extent(points, d =&gt; d[x_var]),\n//      [`${y_var}_range`]: d3.extent(points, d =&gt; d[y_var]),\n    })\n  )\n).flat()\nline_summary = ls.filter(d =&gt; d.n_scores &gt; 1)\n\nlong_runs = line_summary.map(d =&gt; d.runs).flat()\nscoresl = scoresf.filter(d =&gt; long_runs.includes(d.run_id))\n\n// channels for line tooltips (everything in summary other than facet variable)\n//line_vars = Object.keys(line_summary[0]).filter(d =&gt; d !== f_var)\nline_vars = [color_var, z_var, \"n_scores\", \"age_gap\"]\nline_channels = Object.fromEntries(line_vars.map(k =&gt; [k, k]))\n\n// marks for lines\nline_marks = Plot.marks(\n  // facet labels\n  line_facet.text,\n  // spaghetti lines\n  Plot.line(scoresl, {\n    x: x_var,\n    y: y_var,\n    z: z_var,\n    stroke: plt_color,\n    fx: line_facet.fx,\n    fy: line_facet.fy\n  }),\n  // regression lines\n  Plot.linearRegressionY(scoresl, {\n    x: x_var,\n    y: y_var,\n    stroke: \"black\",\n    fx: line_facet.fx,\n    fy: line_facet.fy\n  }),\n    // tooltips\n  Plot.tip(line_summary, Plot.pointer({\n    x: x_var,\n    y: y_var,\n    stroke: plt_color,\n    fx: line_summary_facet.fx,\n    fy: line_summary_facet.fy,\n    channels: line_channels,\n    format: { x: null, y: null, fx: null, fy: null }\n  }))\n)\ndot_facet = facet_wrap(scoresf, f_var, 6)  // facetting for dots\nline_facet = facet_wrap(scoresl, f_var, 6) // facetting for lines\nline_summary_facet = facet_wrap(line_summary, f_var, 6) // facetting for line summary\n\n// map plot_type values to marks\nmarks = ({ dot: dot_marks, line: line_marks })\n\n// values for x axis ticks -- age range with step size 1\nages = d3.range(age_range[0], age_range[1] + 1, 1)\n\n// plot scores!\nscorePlot = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\", fontSize: 12 },\n  width: 1000,\n   grid: true,\n      x: { line: true, ticks: ages, tickFormat: d3.format(\".0f\") },\n      y: { line: true },\n      r: { transform: (s) =&gt; s ? 1/s : 1, range: [0, 4] }, // radius inversely proportional\n  color: {\n    domain: Object.keys(colors),\n    range: Object.values(colors),\n    legend: color_var !== null,\n    className: \"color-legend\"\n  },\n  facet: { axis: null },\n  marks: marks[plot_type]\n})\n\n\n\n Filter by…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSite\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDataset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTask\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteLanguage\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteAdaptive\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteScore type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteScoring model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nitems = transpose(params)\n\ntasks = d3.group(items, d =&gt; d.task_label)\nviewof task_items = Inputs.select(tasks, { label: \"Task\", value: tasks.get(\"Math\") })\ngroups = new Set(task_items.map(d =&gt; d.item_group))\n\nitem_vars = [\"item_group\", \"item_entry\", \"difficulty\", \"n_responses\"]\nitem_channels = Object.fromEntries(item_vars.map(k =&gt; [k, k]))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  style: { fontFamily: \"var(--sans-serif)\", fontSize: 12 },\n  width: 700,\n height: Math.max(150, 50 * groups.size),\n marginLeft: 110,\n   grid: true,\n  facet: { label: null, grid: true },\n  //fy: { padding: 20 },\n  x: { line: true },\n  //y: { insetBottom: 100 },\n  color: { legend: false, scheme: \"viridis\" },\n  r: {range: [1, 4] },\n  marks: [\n    //Plot.frame(),\n    Plot.dot(task_items, Plot.dodgeY(\"middle\", {\n      x: \"difficulty\",\n      fy: \"item_group\",\n      fill: \"item_group\",\n      r: \"n_responses\",\n      sort: {fy: \"x\", color: \"x\", reduce: \"median\"}\n    })),\n    Plot.tip(task_items, Plot.pointer({\n      x: \"difficulty\",\n      fy: \"item_group\",\n      fill: \"item_group\",\n      channels: item_channels,\n      format: { fy: null }\n    }))\n  ]\n})"
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "LEVANTE",
    "section": "",
    "text": "You can access the levante-data-pilots-processed data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"levante\")\ndataset &lt;- user$dataset(\"levante-data-pilots-processed\")\ntable &lt;- dataset$table(\"scores\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"levante\")\ndataset = user.dataset(\"levante-data-pilots-processed\")\ntable = dataset.table(\"scores\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "LEVANTE",
    "section": "",
    "text": "You can access the levante-data-pilots-processed data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"levante\")\ndataset &lt;- user$dataset(\"levante-data-pilots-processed\")\ntable &lt;- dataset$table(\"scores\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"levante\")\ndataset = user.dataset(\"levante-data-pilots-processed\")\ntable = dataset.table(\"scores\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  }
]