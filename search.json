[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "LEVANTE",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "about.html#palmerpenguins",
    "href": "about.html#palmerpenguins",
    "title": "LEVANTE",
    "section": "",
    "text": "The goal of palmerpenguins is to provide a great dataset for data exploration & visualization, as an alternative to iris.\nData were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The dataset contains data for 344 penguins. There are 3 different species of penguins in this dataset, collected from 3 islands in the Palmer Archipelago, Antarctica.\nData are available by CC-0 license in accordance with the Palmer Station LTER Data Policy and the LTER Data Access Policy for Type I data."
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "LEVANTE",
    "section": "",
    "text": "You can access the levante-data-pilots-processed data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"levante\")\ndataset &lt;- user$dataset(\"levante-data-pilots-processed\")\ntable &lt;- dataset$table(\"scores\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"levante\")\ndataset = user.dataset(\"levante-data-pilots-processed\")\ntable = dataset.table(\"scores\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "LEVANTE",
    "section": "",
    "text": "You can access the levante-data-pilots-processed data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"levante\")\ndataset &lt;- user$dataset(\"levante-data-pilots-processed\")\ntable &lt;- dataset$table(\"scores\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"levante\")\ndataset = user.dataset(\"levante-data-pilots-processed\")\ntable = dataset.table(\"scores\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LEVANTE scores",
    "section": "",
    "text": "function interval(range = [], options = {}) {\n  const [min = 0, max = 1] = range;\n  const {\n    step = .001,\n    label = null,\n    value = [min, max],\n    format = ([start, end]) =&gt; `${start} … ${end}`,\n    color,\n    width,\n    theme,\n    __ns__ = randomScope(),\n  } = options;\n\n  const css = `\n#${__ns__} {\n  //font: 13px/1.2 var(--sans-serif);\n  display: flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: auto;\n  flex-direction: column;\n}\n@media only screen and (min-width: 30em) {\n  #${__ns__} {\n    flex-wrap: nowrap;\n    width: 360px;\n  }\n}\n#${__ns__} .label {\n  //width: 120px;\n  //padding: 5px 0 4px 0;\n  //padding: 5px 0 0 0;\n  //margin-right: 6.5px;\n  flex-shrink: 0;\n}\n#${__ns__} .form {\n  display: flex;\n  width: 100%;\n}\n#${__ns__} .range {\n  flex-shrink: 1;\n  width: 100%;\n}\n#${__ns__} .range-slider {\n  width: 100%;\n  margin-bottom: .3em;\n  margin-top: .3em;\n}\n  `;\n  \n  const $range = rangeInput({min, max, value: [value[0], value[1]], step, color, width, theme});\n  const $output = html`&lt;output&gt;`;\n  const $view = html`&lt;div id=${__ns__}&gt;\n${label == null ? '' : html`&lt;div class=\"label\"&gt;${label}`}\n&lt;div class=form&gt;\n  &lt;div class=range&gt;\n    ${$range}&lt;div class=range-output&gt;${$output}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n${html`&lt;style&gt;${css}`}\n  `;\n\n  const update = () =&gt; {\n    const content = format([$range.value[0], $range.value[1]]);\n    if(typeof content === 'string') $output.value = content;\n    else {\n      while($output.lastChild) $output.lastChild.remove();\n      $output.appendChild(content);\n    }\n  };\n  $range.oninput = update;\n  update();\n  \n  return Object.defineProperty($view, 'value', {\n    get: () =&gt; $range.value,\n    set: ([a, b]) =&gt; {\n      $range.value = [a, b];\n      update();\n    },\n  });\n}\n\nfunction rangeInput(options = {}) {\n  const {\n    min = 0,\n    max = 100,\n    step = 'any',\n    value: defaultValue = [min, max],\n    color,\n    width,\n    theme = theme_Flat,\n  } = options;\n  \n  const controls = {};\n  const scope = randomScope();\n  const clamp = (a, b, v) =&gt; v &lt; a ? a : v &gt; b ? b : v;\n\n  // Will be used to sanitize values while avoiding floating point issues.\n  const input = html`&lt;input type=range ${{min, max, step}}&gt;`;\n  \n  const dom = html`&lt;div class=${`${scope} range-slider`} style=${{\n    color,\n    width: cssLength(width),\n  }}&gt;\n  ${controls.track = html`&lt;div class=\"range-track\"&gt;\n    ${controls.zone = html`&lt;div class=\"range-track-zone\"&gt;\n      ${controls.range = html`&lt;div class=\"range-select\" tabindex=0&gt;\n        ${controls.min = html`&lt;div class=\"thumb thumb-min\" tabindex=0&gt;`}\n        ${controls.max = html`&lt;div class=\"thumb thumb-max\" tabindex=0&gt;`}\n      `}\n    `}\n  `}\n  ${html`&lt;style&gt;${theme.replace(/:scope\\b/g, '.'+scope)}`}\n&lt;/div&gt;`;\n\n  let value = [], changed = false;\n  Object.defineProperty(dom, 'value', {\n    get: () =&gt; [...value],\n    set: ([a, b]) =&gt; {\n      value = sanitize(a, b);\n      updateRange();\n    },\n  });\n\n  const sanitize = (a, b) =&gt; {\n    a = isNaN(a) ? min : ((input.value = a), input.valueAsNumber);\n    b = isNaN(b) ? max : ((input.value = b), input.valueAsNumber);\n    return [Math.min(a, b), Math.max(a, b)];\n  }\n  \n  const updateRange = () =&gt; {\n    const ratio = v =&gt; (v - min) / (max - min);\n    dom.style.setProperty('--range-min', `${ratio(value[0]) * 100}%`);\n    dom.style.setProperty('--range-max', `${ratio(value[1]) * 100}%`);\n  };\n\n  const dispatch = name =&gt; {\n    dom.dispatchEvent(new Event(name, {bubbles: true}));\n  };\n  const setValue = (vmin, vmax) =&gt; {\n    const [pmin, pmax] = value;\n    value = sanitize(vmin, vmax);\n    updateRange();\n    // Only dispatch if values have changed.\n    if(pmin === value[0] && pmax === value[1]) return;\n    dispatch('input');\n    changed = true;\n  };\n  \n  setValue(...defaultValue);\n  \n  // Mousemove handlers.\n  const handlers = new Map([\n    [controls.min, (dt, ov) =&gt; {\n      const v = clamp(min, ov[1], ov[0] + dt * (max - min));\n      setValue(v, ov[1]);\n    }],\n    [controls.max, (dt, ov) =&gt; {\n      const v = clamp(ov[0], max, ov[1] + dt * (max - min));\n      setValue(ov[0], v);\n    }],\n    [controls.range, (dt, ov) =&gt; {\n      const d = ov[1] - ov[0];\n      const v = clamp(min, max - d, ov[0] + dt * (max - min));\n      setValue(v, v + d);\n    }],\n  ]);\n  \n  // Returns client offset object.\n  const pointer = e =&gt; e.touches ? e.touches[0] : e;\n  // Note: Chrome defaults \"passive\" for touch events to true.\n  const on  = (e, fn) =&gt; e.split(' ').map(e =&gt; document.addEventListener(e, fn, {passive: false}));\n  const off = (e, fn) =&gt; e.split(' ').map(e =&gt; document.removeEventListener(e, fn, {passive: false}));\n  \n  let initialX, initialV, target, dragging = false;\n  function handleDrag(e) {\n    // Gracefully handle exit and reentry of the viewport.\n    if(!e.buttons && !e.touches) {\n      handleDragStop();\n      return;\n    }\n    dragging = true;\n    const w = controls.zone.getBoundingClientRect().width;\n    e.preventDefault();\n    handlers.get(target)((pointer(e).clientX - initialX) / w, initialV);\n  }\n  \n  \n  function handleDragStop(e) {\n    off('mousemove touchmove', handleDrag);\n    off('mouseup touchend', handleDragStop);\n    if(changed) dispatch('change');\n  }\n  \n  invalidation.then(handleDragStop);\n  \n  dom.ontouchstart = dom.onmousedown = e =&gt; {\n    dragging = false;\n    changed = false;\n    if(!handlers.has(e.target)) return;\n    on('mousemove touchmove', handleDrag);\n    on('mouseup touchend', handleDragStop);\n    e.preventDefault();\n    e.stopPropagation();\n    \n    target = e.target;\n    initialX = pointer(e).clientX;\n    initialV = value.slice();\n  };\n  \n  controls.track.onclick = e =&gt; {\n    if(dragging) return;\n    changed = false;\n    const r = controls.zone.getBoundingClientRect();\n    const t = clamp(0, 1, (pointer(e).clientX - r.left) / r.width);\n    const v = min + t * (max - min);\n    const [vmin, vmax] = value, d = vmax - vmin;\n    if(v &lt; vmin) setValue(v, v + d);\n    else if(v &gt; vmax) setValue(v - d, v);\n    if(changed) dispatch('change');\n  };\n  \n  return dom;\n}\n\nfunction randomScope(prefix = 'scope-') {\n  return prefix + (performance.now() + Math.random()).toString(32).replace('.', '-');\n}\n\ncssLength = v =&gt; v == null ? null : typeof v === 'number' ? `${v}px` : `${v}`\n\nhtml = htl.html\n\ntheme_Flat = `\n/* Options */\n:scope {\n  color: #3b99fc;\n  width: 240px;\n}\n\n:scope {\n  position: relative;\n  display: inline-block;\n  --thumb-size: 15px;\n  --thumb-radius: calc(var(--thumb-size) / 2);\n  //padding: var(--thumb-radius) 0;\n  margin: 2px;\n  vertical-align: middle;\n}\n:scope .range-track {\n  box-sizing: border-box;\n  position: relative;\n  height: 7px;\n  background-color: hsl(0, 0%, 80%);\n  overflow: visible;\n  border-radius: 4px;\n  padding: 0 var(--thumb-radius);\n}\n:scope .range-track-zone {\n  box-sizing: border-box;\n  position: relative;\n}\n:scope .range-select {\n  box-sizing: border-box;\n  position: relative;\n  left: var(--range-min);\n  width: calc(var(--range-max) - var(--range-min));\n  cursor: ew-resize;\n  background: currentColor;\n  height: 7px;\n  border: inherit;\n}\n/* Expands the hotspot area. */\n:scope .range-select:before {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: var(--thumb-size);\n  left: 0;\n  top: calc(2px - var(--thumb-radius));\n}\n:scope .range-select:focus,\n:scope .thumb:focus {\n  outline: none;\n}\n:scope .thumb {\n  box-sizing: border-box;\n  position: absolute;\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n\n  background: #fcfcfc;\n  top: -4px;\n  border-radius: 100%;\n  border: 1px solid hsl(0,0%,55%);\n  cursor: default;\n  margin: 0;\n}\n:scope .thumb:active {\n  box-shadow: inset 0 var(--thumb-size) #0002;\n}\n:scope .thumb-min {\n  left: calc(-1px - var(--thumb-radius));\n}\n:scope .thumb-max {\n  right: calc(-1px - var(--thumb-radius));\n}\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntol = ({\n    QualBright: ['#4477AA', '#EE6677', '#228833', '#CCBB44', '#66CCEE','#AA3377'],\n    QualHighContrast: ['#004488', '#DDAA33', '#BB5566'],\n    QualVibrant: ['#EE7733', '#0077BB', '#33BBEE', '#EE3377', '#CC3311', '#009988'],\n    QualMuted: ['#CC6677', '#332288', '#DDCC77', '#117733', '#88CCEE','#882255', '#44AA99', '#999933', '#AA4499'],\n    QualLight: ['#77AADD', '#EE8866', '#EEDD88', '#FFAABB', '#99DDFF', '#44BB99', '#BBCC33', '#AAAA00'],\n    Sunset: ['#364B9A', '#4A7BB7', '#6EA6CD', '#98CAE1', '#C2E4EF', '#EAECCC', '#FEDA8B', '#FDB366', '#F67E4B', '#DD3D2D', '#A50026'],\n    BuRd: ['#2166AC', '#4393C3', '#92C5DE', '#D1E5F0', '#F7F7F7', '#FDDBC7', '#F4A582', '#D6604D', '#B2182B'],\n    PRGn: ['#762A83', '#9970AB', '#C2A5CF', '#E7D4E8', '#F7F7F7', '#D9F0D3', '#ACD39E', '#5AAE61', '#1B7837'],\n    YlOrBr: ['#FFFFE5', '#FFF7BC', '#FEE391', '#FEC44F', '#FB9A29',\n                '#EC7014', '#CC4C02', '#993404', '#662506'],\n    Iridescent: ['#FEFBE9', '#FCF7D5', '#F5F3C1', '#EAF0B5', '#DDECBF',\n                '#D0E7CA', '#C2E3D2', '#B5DDD8', '#A8D8DC', '#9BD2E1',\n                '#8DCBE4', '#81C4E7', '#7BBCE7', '#7EB2E4', '#88A5DD',\n                '#9398D2', '#9B8AC4', '#9D7DB2', '#9A709E', '#906388',\n                '#805770', '#684957', '#46353A'],\n    RainbowPuRd: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222'],\n    RainbowPuBr: ['#6F4C9B', '#6059A9', '#5568B8', '#4E79C5', '#4D8AC6',\n                '#4E96BC', '#549EB3', '#59A5A9', '#60AB9E', '#69B190',\n                '#77B77D', '#8CBC68', '#A6BE54', '#BEBC48', '#D1B541',\n                '#DDAA3C', '#E49C39', '#E78C35', '#E67932', '#E4632D',\n                '#DF4828', '#DA2222', '#B8221E', '#95211B', '#721E17',\n                '#521A13'],\n    RainbowWhRd: ['#E8ECFB', '#DDD8EF', '#D1C1E1', '#C3A8D1', '#B58FC2',\n                '#A778B4', '#9B62A7', '#8C4E99', '#6F4C9B', '#6059A9',\n                '#5568B8', '#4E79C5', '#4D8AC6', '#4E96BC', '#549EB3',\n                '#59A5A9', '#60AB9E', '#69B190', '#77B77D', '#8CBC68',\n                '#A6BE54', '#BEBC48', '#D1B541', '#DDAA3C', '#E49C39',\n                '#E78C35', '#E67932', '#E4632D', '#DF4828', '#DA2222'],\n    RainbowDiscrete: ['#E8ECFB', '#D9CCE3', '#D1BBD7', '#CAACCB', '#BA8DB4',\n                '#AE76A3', '#AA6F9E', '#994F88', '#882E72', '#1965B0',\n                '#437DBF', '#5289C7', '#6195CF', '#7BAFDE', '#4EB265',\n                '#90C987', '#CAE0AB', '#F7F056', '#F7CB45', '#F6C141',\n                '#F4A736', '#F1932D', '#EE8026', '#E8601C', '#E65518',\n                '#DC050C', '#A5170E', '#72190E', '#42150A']\n})\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 80px;\n  }\n\n  form.${ns} {\n    flex-wrap: wrap;\n  }\n  \n  .plot-inputs form.${ns} {\n    flex-direction: column;\n  }\n  \n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    margin-bottom: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #fbe4b4;\n  }\n  \n  .${ns} input[type=\"checkbox\"] {\n    accent-color: black;\n    margin-bottom: 0;\n  }\n\n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    //width: auto;\n  }\n  \n  .${ns} .hist {\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    row-gap: 0em;\n  }\n\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot = import(\"https://esm.sh/@observablehq/plot@0.6.17\")\ninitial_scores = transpose(data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntag_vars = [\"site\", \"dataset\", \"task_label\", \"language\", \"adaptive\", \"score_type\", \"scoring_model\"]\nvar_opts = (df, v) =&gt; ([v, [...new Set(df.map(d =&gt; d[v]))]])\nget_tags = (df, tags) =&gt; Object.fromEntries(tags.map(v =&gt; var_opts(df, v)))\ntags = get_tags(scores, tag_vars)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntask_info = ({\n    \"hf\": \"Hearts & Flowers\",\n   \"sds\": \"Same & Different\",\n    \"mg\": \"Memory\",\n  \"math\": \"Math\",\n\"matrix\": \"Pattern Matching\",\n  \"mrot\": \"Shape Rotation\",\n  \"trog\": \"Sentence Understanding\",\n \"vocab\": \"Vocabulary\",\n   \"tom\": \"Stories\",\n    \"pa\": \"Language Sounds\",\n   \"sre\": \"Sentence Reading\",\n   \"swr\": \"Word Reading\",\n})\n\nprep_scores = sc =&gt; {\n  return sc.map(obj =&gt; {\n    return tag_vars.reduce((acc, key) =&gt; ({\n      ...acc,\n      [key]: acc[key] === undefined || acc[key] === null ? \"NA\" : acc[key]\n    }), {\n      ...obj,\n      adaptive: obj.adaptive ? \"adaptive\" : \"non-adaptive\",\n      task_label: task_info[obj.task_code]\n    })\n  }).sort((a, b) =&gt; {\n    const keysOrder = Object.keys(task_info);\n    return keysOrder.indexOf(a.task_code) - keysOrder.indexOf(b.task_code);\n  })\n}\n\nmutable scores = prep_scores(initial_scores)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvi = ({\n  \"age\":           { label: \"Age (years)\",      filter: true,  tip: true,  range: [4, 12] },\n  \"age_gap\":       { label: \"Age gap (months)\", filter: true,  tip: false, range: [0, 24] },\n  \"score\":         { label: \"Score\",            filter: false, tip: true,  range: null    },\n  \"score_se\":      { label: \"Score SE\",         filter: false, tip: true,  range: null    },\n  \"num_attempted\": { label: \"num_attempted\",    filter: false, tip: true,  range: null    }\n})\n\n// info for categorical variables\n// color = include in color dropdown?, tip = include in tooltip?\n// note: filter property not actually used programmatically\nti = ({\n  \"site\":          { label: \"Site\",          filter: true,  color: true,  tip: true  },\n  \"dataset\":       { label: \"Dataset\",       filter: true,  color: true,  tip: true  },\n  \"task_label\":    { label: \"Task\",          filter: true,  color: false, tip: false },\n  \"language\":      { label: \"Language\",      filter: true,  color: true,  tip: false },\n  \"adaptive\":      { label: \"Adaptive\",      filter: true,  color: true,  tip: false },\n  \"score_type\":    { label: \"Score type\",    filter: true,  color: true,  tip: false },\n  \"scoring_model\": { label: \"Scoring model\", filter: true,  color: true,  tip: false },\n  \"run_id\":        { label: \"run_id\",        filter: false, color: false, tip: true  },\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninterval_format = ([start, end]) =&gt; `[${Plot.formatNumber(\"en-US\")(start)}; ${Plot.formatNumber(\"en-US\")(end)}]`\n\n// integer-rounded min and max of an array\n// range = (x) =&gt; [Math.floor(d3.min(x)), Math.ceil(d3.max(x))]\n\n// interval input for a given numeric variable\nvar_interval = (v) =&gt; {\n  return interval(vi[v].range, {\n    step: 1, label: vi[v].label, format: interval_format, width: \"95%\", color: \"#f7ca69\"\n  })\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScoresItems\n\n\ncat_checkbox = (tags, t) =&gt; Inputs.checkbox(tags[t], {value: tags[t]})\nviewof age_range = var_interval(\"age\")\nviewof age_gap_range = var_interval(\"age_gap\")\nviewof site_vals = cat_checkbox(tags, \"site\")\nviewof dataset_vals = cat_checkbox(tags, \"dataset\")\nviewof task_label_vals = cat_checkbox(tags, \"task_label\")\nviewof language_vals = cat_checkbox(tags, \"language\")\nviewof adaptive_vals = cat_checkbox(tags, \"adaptive\")\nviewof score_type_vals = cat_checkbox(tags, \"score_type\")\nviewof scoring_model_vals = cat_checkbox(tags, \"scoring_model\")\n// populates datasource selector -- first click should open redivis auth pop up\nviewof auth_button = Inputs.button(\"Populate data sources\", {\n  reduce: async () =&gt; {\n    const ds = await getDatasets()\n    mutable dn = allowedDatasetNames(ds)\n  }\n})\nmutable dn = [] // available datasource names\nviewof datasource = Inputs.select(dn)\n// replaces current scores with scores from selected datasource\nviewof switch_datasource_button = Inputs.button(\"Switch data source\", {\n  reduce: async () =&gt; {\n    const ds_scores = await getScores(datasource);\n    mutable scores = prep_scores(ds_scores);\n  }\n})\nrange_filter = (v, v_range) =&gt; {\n  return (d) =&gt; d[v] === undefined || (d[v] &gt;= v_range[0] & d[v] &lt;= v_range[1])\n}\n\n// generate overlap filter function for a given categorical variable and input values\noverlap_filter = (t, t_vals) =&gt; {\n  return (d) =&gt; t_vals.some(v =&gt; d[t].includes(v))\n}\n\n// generate overlap filter function as above but that defaults to including everything if input values empty\noverlap_null_filter = (t, t_vals) =&gt; {\n  return (d) =&gt; t_vals.length ? t_vals.some(v =&gt; d[t].includes(v)) : true\n}\n\n// specify range-based inputs (as variable, values)\nrange_inputs = ([\n  { v: \"age\", vals: age_range },\n])\n  \n// specify overlap-based inputs (as variable, values)\noverlap_inputs = ([\n    { v: \"site\",          vals: site_vals          },\n    { v: \"dataset\",       vals: dataset_vals       },\n    { v: \"task_label\",    vals: task_label_vals    },\n    { v: \"language\",      vals: language_vals      },\n    { v: \"adaptive\",      vals: adaptive_vals      },\n    { v: \"score_type\",    vals: score_type_vals    },\n    { v: \"scoring_model\", vals: scoring_model_vals },\n])\n\n//apply_filters = (df, ri, oi) =&gt; {\n//  const overlap_filters = oi.map(({ v, vals }) =&gt; overlap_filter(v, vals))\n//  const range_filters = ri.map(({ v, vals }) =&gt; range_filter(v, vals))\n//  const all_filters = [...range_filters, ...overlap_filters]\n//  return all_filters.reduce((d, fun) =&gt; d.filter(fun), df)\n//}\n//sf = apply_filters(scores, range_inputs, overlap_inputs)\n\n// generate filter function for each input and combine them\nrange_filters = range_inputs.map(({ v, vals }) =&gt; range_filter(v, vals))\noverlap_filters = overlap_inputs.map(({ v, vals }) =&gt; overlap_filter(v, vals))\nall_filters = [...range_filters, ...overlap_filters]\n\n// apply filters to score data\nsf = all_filters.reduce((sc, fun) =&gt; sc.filter(fun), scores)\n\n// apply age gap filter\nag = ls.filter(d =&gt; d.age_gap === NaN || (d.age_gap &gt;= age_gap_range[0] & d.age_gap &lt;= age_gap_range[1]))\nag_runs = ag.map(d =&gt; d.runs).flat()\nscoresf = sf.filter(d =&gt; ag_runs.includes(d.run_id))\n// plot type selector\nviewof plot_type = Inputs.radio(\n  new Map([[\"Cross-sectional\", \"dot\"], [\"Longitudinal\", \"line\"]]),\n  {value: \"dot\", label: \"Data view\"}\n)\ncat_array = Object.keys(ti).filter((t) =&gt; ti[t].color).map((t) =&gt; [ti[t].label, t])\ncat_vars = new Map([[\"None\", null], ...cat_array])\nviewof color_var = Inputs.select(cat_vars, {value: \"site\", label: \"Color\"})\nx_var = \"age\"        // x\ny_var = \"score\"      // y\nr_var = \"score_se\"   // dot radius\nz_var = \"user_id\"    // line group\nf_var = \"task_label\" // facets\n\n//\n// plot colors\n// set up to keep color mapping consistent regardless of filters but include\n// only present values in legend\n//\nscheme = tol.QualMuted // color scheme\ndefault_color = scheme[0] // default color when there's no color variable\nunk_color = \"lightgrey\" // color for missing values\nplt_color = color_var || default_color // plot color variable\n// color variable values -- null or all possible values for variable except NA\ncolor_vals = color_var === null ? [default_color] : tags[color_var].filter((v) =&gt; v !== \"NA\")\n\n// domain: values + NA\ncolor_domain = [...color_vals, \"NA\"]\n// range: corresponding values from scheme + missing color\ncolor_range = [...scheme.slice(0, color_vals.length), unk_color]\n// map from domain to range\ncolor_map = color_domain.map((v, i) =&gt; [v, color_range[i]])\n// drop elements from map if values not in data\ncolors = Object.fromEntries(color_map.filter(([k, v]) =&gt; scoresf.map((d) =&gt; d[color_var]).includes(k)))\n\n// create facet specification to emulate facet wrap\n// given data, column name to facet by, and number of columns\nfacet_wrap = (df, col, ncol) =&gt; {\n  const keys = Array.from(d3.union(df.map((d) =&gt; d[col])));\n  const index = new Map(keys.map((key, i) =&gt; [key, i]));\n  const fx = (key) =&gt; index.get(key) % ncol;\n  const fy = (key) =&gt; Math.floor(index.get(key) / ncol);\n  return ({\n    fx: (d) =&gt; fx(d[col]),\n    fy: (d) =&gt; fy(d[col]),\n    text: Plot.text(keys, {fx, fy, dy: -12, frameAnchor: \"top\", fontWeight: \"bold\"})\n    //text: Plot.text(keys, {fx, fy, frameAnchor: \"top\", fontWeight: \"bold\"})\n  })\n}\nall_vars = [...Object.entries(ti), ...Object.entries(vi)] // all variables\ntip_vars = all_vars.filter(([k, v]) =&gt; v.tip) // variables with \"tip\" property\ndot_channels = Object.fromEntries(tip_vars.map(([k, v]) =&gt; [k, k]))\n\n// marks for dots\ndot_marks = Plot.marks(\n  // facet labels\n  dot_facet.text,\n  // points\n  Plot.dot(scoresf, {\n    x: x_var,\n    y: y_var,\n    r: r_var,\n    stroke: plt_color,\n    strokeOpacity: 0.5,\n    fx: dot_facet.fx,\n    fy: dot_facet.fy\n  }),\n  // regression lines\n  Plot.linearRegressionY(scoresf, {\n    x: x_var,\n    y: y_var,\n    stroke: \"black\",\n    fx: dot_facet.fx,\n    fy: dot_facet.fy\n  }),\n  // tooltips\n  Plot.tip(scoresf, Plot.pointer({\n    x: x_var,\n    y: y_var,\n    stroke: plt_color,\n    fx: dot_facet.fx,\n    fy: dot_facet.fy,\n    channels: dot_channels,\n    format: { fx: null, fy: null }\n  }))\n)\nls = Array.from(\n  d3.group(sf, d =&gt; d[f_var], d =&gt; d[z_var]),\n  ([f_val, z_map]) =&gt; Array.from(\n    z_map,\n    ([z_val, points]) =&gt; ({\n      [f_var]: f_val,\n      [z_var]: z_val,\n      [color_var]: points[0][color_var],\n      [x_var]: d3.mean(points, d =&gt; d[x_var]),\n      [y_var]: d3.mean(points, d =&gt; d[y_var]),\n      n_scores: points.length,\n      age_gap: 12*(d3.max(points, d =&gt; d[x_var]) - d3.min(points, d =&gt; d[x_var])),\n      runs: points.map(d =&gt; d.run_id)\n//      [`${x_var}_mean`]: d3.mean(points, d =&gt; d[x_var]),\n//      [`${y_var}_mean`]: d3.mean(points, d =&gt; d[y_var]),\n//      [`${x_var}_range`]: d3.extent(points, d =&gt; d[x_var]),\n//      [`${y_var}_range`]: d3.extent(points, d =&gt; d[y_var]),\n    })\n  )\n).flat()\n\n// filter line segment summary to users with more than one score\nline_summary = ls.filter(d =&gt; d.n_scores &gt; 1)\n// filter scores to runs filtered line summary\nlong_runs = line_summary.map(d =&gt; d.runs).flat()\nscoresl = scoresf.filter(d =&gt; long_runs.includes(d.run_id))\n\n// channels for line tooltips (everything in summary other than facet variable)\n//line_vars = Object.keys(line_summary[0]).filter(d =&gt; d !== f_var)\nline_vars = [color_var, z_var, \"n_scores\", \"age_gap\"]\nline_channels = Object.fromEntries(line_vars.map(k =&gt; [k, k]))\n\n// marks for lines\nline_marks = Plot.marks(\n  // facet labels\n  line_facet.text,\n  // spaghetti lines\n  Plot.line(scoresl, {\n    x: x_var,\n    y: y_var,\n    z: z_var,\n    stroke: plt_color,\n    fx: line_facet.fx,\n    fy: line_facet.fy\n  }),\n  // regression lines\n  Plot.linearRegressionY(scoresl, {\n    x: x_var,\n    y: y_var,\n    stroke: \"black\",\n    fx: line_facet.fx,\n    fy: line_facet.fy\n  }),\n    // tooltips\n  Plot.tip(line_summary, Plot.pointer({\n    x: x_var,\n    y: y_var,\n    stroke: plt_color,\n    fx: line_summary_facet.fx,\n    fy: line_summary_facet.fy,\n    channels: line_channels,\n    format: { x: null, y: null, fx: null, fy: null }\n  }))\n)\ndot_facet = facet_wrap(scoresf, f_var, 6)  // facetting for dots\nline_facet = facet_wrap(scoresl, f_var, 6) // facetting for lines\nline_summary_facet = facet_wrap(line_summary, f_var, 6) // facetting for line summary\n\n// map plot_type values to marks\nmarks = ({ dot: dot_marks, line: line_marks })\n\n// values for x axis ticks -- age range with step size 1\n//ages = d3.range(age_range[0], age_range[1] + 1, 1)\nspan = (x) =&gt; [Math.floor(d3.min(x)), Math.ceil(d3.max(x))]\nage_span = span(scoresf.map(d =&gt; d.age))\nages = d3.range(age_span[0], age_span[1] + 1, 1)\n\n// plot scores!\nscorePlot = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\", fontSize: 12 },\n  width: 1000,\n   grid: true,\n      x: { line: true, domain: age_span, ticks: ages, tickFormat: d3.format(\".0f\") },\n      y: { line: true },\n      r: { transform: (s) =&gt; s ? 1/s : 1, range: [0, 4] }, // radius inversely proportional\n  color: {\n    domain: Object.keys(colors),\n    range: Object.values(colors),\n    legend: color_var !== null,\n    className: \"color-legend\"\n  },\n  facet: { axis: null }, // hide facet labels\n  marks: marks[plot_type] // use marks according to plot type (dot/line)\n})\n\n\n\n Filter by…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSite\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDataset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTask\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteLanguage\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteAdaptive\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteScore type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteScoring model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Change data source…\n\n\nNote: To change data sources, you need a Redivis account. Click on the button below to log into your Redivis account and list the datasets that you have access to.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nitems = transpose(items_)\nmodels = transpose(models_)\n\n// group items by test, use for task selector\nitems_coded = items.map(d =&gt; ({...d, lang_group: `${d.item_group} | ${d.language}` }))\ntasks = d3.group(items_coded, d =&gt; d.task_label)\nviewof task_items = Inputs.select(tasks, { label: \"Task\", value: tasks.get(\"Math\") })\nitem_groups = new Set(task_items.map(d =&gt; d.item_group))\n\n// channels for item tooltips\nitem_vars = [\"item_group\", \"item_uid\", \"n_responses\", \"difficulty\"]\nitem_channels = Object.fromEntries(item_vars.map(k =&gt; [k, k]))\n\ntask = task_items[0].task_code // current items' task code\nmodel = models.filter(t =&gt; t.task_code === task)[0] // current items' model type\nby_lang = model.language !== undefined // whether items' model is by language\n\n// sort order of languages -- alpha\nlangs = d3.sort(new Set(task_items.map(d =&gt; d.language)))\n// sort order of item groups -- median difficulty (in first language)\nl0_items = task_items.filter(d =&gt; d.language === langs[0])\ngroups = d3.groupSort(l0_items, g =&gt; d3.median(g, d =&gt; d.difficulty), d =&gt; d.item_group)\n// sort order of language + item group -- above combined\nindeces = d3.groups(task_items, d =&gt; d.lang_group).map(([lang_group, vals]) =&gt; [lang_group, langs.indexOf(vals[0].language), groups.indexOf(vals[0].item_group)])\nlang_groups = d3.sort(indeces, d =&gt; d[1], d =&gt; d[2]).map(d =&gt; d[0])\n\n// plot height in pixels for each task\nheights = ({\n  \"hf\":     180,\n  \"sds\":    240,\n  \"mg\":     220,\n  \"math\":   490,\n  \"matrix\": 220,\n  \"mrot\":   150,\n  \"trog\":   690,\n  \"vocab\":  340,\n  \"tom\":    500,\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// info on items' model registry record\nhtml`&lt;div class=\"source\"&gt;&lt;a href=\"${model.file_link}\" target=\"_blank\"&gt;Source&lt;/a&gt;: ${model.itemtype} IRT model (${model.invariance_label}) fit to ${model.n_runs} runs, uploaded on ${model.added_at_date} to model registry version ${model.registry_version}.&lt;/div&gt;`\n\n\n\n\n\n\n\nitem_opts = ({\n         style: { fontFamily: \"var(--sans-serif)\", fontSize: 12, overflow: \"visible\" },\n         width: 700,\n        height: heights[task],\n    marginLeft: 120,\n     marginTop: 50,\n  marginBottom: 40,\n          grid: true,\n         facet: { label: null, grid: true },\n             x: { line: true },\n             r: { range: [1, 4] },\n            fy: { domain: by_lang ? lang_groups : groups },\n         color: { domain: groups.length &gt; 1 ? groups : langs, legend: false, scheme: \"viridis\" },\n})\n\nitem_dots = (x_var) =&gt; {\n  return Plot.marks(\n    Plot.dot(task_items, Plot.dodgeY(\"middle\", {\n    x: x_var,\n    fy: by_lang ? \"lang_group\" : \"item_group\",\n    fill: groups.length &gt; 1 ? \"item_group\" : \"language\",\n    r: \"n_responses\",\n    tip: { format: { fy: false }, anchor: \"left\" },\n    channels: item_channels\n    }))\n  )\n}\n\n// item difficulties plot\nPlot.plot({\n  ...item_opts,\n  marks: item_dots(\"difficulty\")\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// item discriminations plot -- hide if model isn't 2PL\nmodel.itemtype !== \"2PL\" ? html`&lt;div&gt;&lt;/div&gt;` :\nPlot.plot({\n  ...item_opts,\n  marks: item_dots(\"discrimination\")\n})\n\n\n\n\n\n\n\n\n\n\n\nredivis = require(\"redivis\")\n\n// get scores table for a given dataset\nasync function getScores(dataset) {\n  console.log('getting scores')\n  const rows = await redivis\n    .organization('LEVANTE')\n    .dataset(dataset)\n    .table('scores')\n    .listRows({ max_results: 3 })\n  console.log('got scores')\n  return rows;\n}\n\n// get references to all LEVANTE datasets (with \"properties\" populated)\nasync function getDatasets() {\n  const ds = await redivis\n    .organization('LEVANTE')\n    .listDatasets()\n  return await Promise.all(ds.map(d =&gt; d.get()))\n}\n\n// filter datasets by authed user's access + get names of \"processed\" datasets\nallowedDatasetNames = (ds) =&gt; {\n  const accessLevels = [\"data\", \"edit\"]\n  return ds.filter(d =&gt; accessLevels.includes(d.properties.accessLevel))\n    .map(d =&gt; d.name)\n    .filter(n =&gt; n.match(\"processed\"))\n    .sort()\n}"
  }
]